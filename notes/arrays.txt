Arrays
------
1. Given an array A[] and a number x, check for pair in A[] with sum as x
  - Sort the array
  - Maintain two index pointers, say start & end
  - Initialize start index to left most index, 0 and end index to right most index, N-1
  - Loop while start < end
  - Sum the array elements in the start and end pointers
  - If the sum is less than x, increment start pointer
  - If the sum is grater than x, decrement end pointer
  - Time: Depends on sorting algorithm being used. 
                     merge sort or heap sort - O(n logn) for all cases
					 quick sort O(n logn) for best & average, O(n^2) for worst case
  - Space: Again, depends on sorting algorithm. O(n) for merge sort and O(1) for Heap Sort.
  
2. Majority element
  Majority element in an array of size n is an element that appears more than n/2 times (and hence there is at most one such element).
  a. Method1 - HashMap
  - Maintain a HashMap<Integer, Integer> with key&value as element&count.  
  - For every element in the array, check if it exists in the HashMap
    - If found, increment the count value.
	- If not found, insert with count as 1.
	- At any point, if the count becomes more than n/2, then return the value.
  - Time: O(n) Space: O(n)
  
  b. Method2
  - This is a two step process.
  - step1: Find an element occurring most of the time in the array
  - step2: check if the element obtained in step1 is majority element
  
  - step1: Moore's voting algorithm
    - Initialise the first element as majority element and count as 1.
	- For every element in the array,
	  - if current element is same as majority element, increment count.
	  - if current element is not same as majority element, decrement count.
	  - if count reaches zero, change the majority element to the current element
	- Return the majority element
	- Time: O(n) Space: O(1)
  - step2: 
    - Find the number of occurrences for the majority element from step1.
	- if occurrences is greater than n/2, return majority element
	- if not there is no majority element
	- Time: O(n) Space: O(1)
  
3. Given an array of positive integers. All numbers occur even number of times except one number which occurs odd number of times. 
   Find the number in O(n) time & constant space.
  - Initialize result as 0;
  - For every element in the array, do bitwise XOR ^ operation;  res = res ^ element
  - Finally result has the array element with odd occurrences.
  - Time: O(n)
  
4. Largest sum contiguous subarray
  - Maintain two values 1. sum of the current subarray, currSubArraySum 2. maximum sum of sub arrays encountered so far, maxSumSofar
  - Initialize currSubArraySum as 0 and maxSumSofar as MIN_VALUE
  - For every element in the array,
    - add element to currSubArraySum
	- if currSubArraySum is greater than maxSumSofar, set maxSumSofar = currSubArraySum	
	  (set sub array start index as tempStartIndex and sub array end index as current position)
	- if currSubArraySum is less than 0, reset currSubArraySum = 0 (set sub array tempStartIndex as current position's next)
  - Time: O(n)

5. Find an element x in an sorted rotated array
  - Find the pivot index. ex. for array 3, 4, 5, 6, 1, 2 pivot index is 3. If array is not rotated at all, then pivot index is -1
  - If we find pivot index, compare x with pivot element and return if it matches. stop
  - If x is greater than a[0] then binary search in left array ie 0 to pivot-1
    Else binary search in right array pivot+1 to N-1 (where N is array.size)
  - Time: O(log n)
	
  - Find Pivot Index: (binary search variation)
    - Base cases
	        if (high < low)  return -1;
            if (high == low) return low;
    - Find the middle element
	- if a[mid] > a[mid+1], then return mid as pivot index
	- if a[mid-1] > a[mid], then return mid-1 as pivot index
	- if a[low] > a[mid], then recursively find pivot in left array, ie low to mid-1
	  else recursively find pivot in right array, ie  mid+1 to high
  
6. There are two sorted arrays. First one is of size m+n containing only m elements. Another one is of size n and contains n elements. 
   Merge these two arrays into the first array of size m+n such that the output is sorted.
  - Move m elements in the first array to end. (now the first n spaces would be empty)
  - Start from nth element in first array and 0th element in second array, merge them into first array.
  - Time: O(m+n)

7. Given 2 sorted arrays A and B of size n each. Write an algorithm to find the median of the array 
   obtained after merging the above 2 arrays(i.e. array of length 2n). The complexity should be O(log(n)) 
  - Base cases: 
	if (n <= 0)
        return -1;
    if (n == 1)
        return (ar1[0] + ar2[0])/2;
    if (n == 2)
        return (max(ar1[0], ar2[0]) + min(ar1[1], ar2[1])) / 2;  
		
  - Find the median m1 of arr1
  - Find the median m2 of arr2
  - if m1 and m2 are same, return m1 or m2. stop
  - if (m1 < m2), median lies between arr1[m1........] and arr2[.........m2]
  - else if (m2 < m1), median lies between arr2[m2........] and arr1[........m1]
 
8. Reverse an array
  - Initialise left and right indexes as 0 and n-1 respectively
  - While left < right do the following
    - swap a[left] with a[right]
	- increment left, decrement right
  - Time: O(n)

9. Array rotation - Reversal Algorithm
  - Reverse 0 to d-1
  - Reverse d to n-1
  - Reverese 0 to n-1
  - Time: O(n)

10. Maximum sum such that no two elements are adjacent  
  - Maintain two values 1. including the current element, incl and 2. excluding the current element, excl
  - Initialize incl as a[0] and excl as 0
  - incl = sum of excl with current element
  - excl = max(incl or excl of previous element) 
   [since we need previous element's incl and excl values, capture them before calculating the incl value of current element]
  - Time: O(n)

11. Write a program to print all the LEADERS in the array.An element is leader if it is greater than all the elements to its right side. 
    And the rightmost element is always a leader. eg: for array {16, 17, 4, 3, 5, 2}, leaders are 17, 5 and 2.
  - Keep track of the maxValue from the right most end of the array. Initially set the right most element as maxValue
  - When the maxValue gets changed by any current element from right to left, then current element is a LEADER
  - Time:O(n)

12. Print the elements of an array in the decreasing frequency; if 2 numbers have same frequency then print the one which came 1st
	E.g. 2 5 2 8 5 6 8 8 output: 8 8 8 2 2 5 5 6.
  - Use any stable sorting algorithm. Merge sort is a stable algorithm
  
13. Count Inversions in an array
    Inversion Count is how far (or close) the array is from being sorted. If array is already sorted then inversion count is 0. 
	If array is sorted in reverse order that inversion count is maximum. a[i] and a[j] form an inversion if a[i] > a[j] and i < j 
	eg: The sequence 2, 4, 1, 3, 5 has three inversions (2, 1), (4, 1), (4, 3).
  - Implement merge sort
  - In merge step, when a[i] > b[j], then all the elements after a[i] till mid is added to inversion count.
  - Time: O(n log n) [merging step takes O(n), dividing into sub problems takes O(log n)]

14. Algorithm to find if a given integer x appears more than n/2 times in a sorted array of n integers.
  - Use binary search to find the first occurrence of x.
  - How to find first occurence in binary search: 
    arr[mid] is first occurrence if x is one of the following is true:
        (i)  mid == 0 and arr[mid] == x
        (ii) arr[mid-1] < x and arr[mid] == x
  - Check if x is present in more than n/2 times.
  - Time: O(log n)

15. Maximum and minimum of an array using minimum number of comparisons
  - Get the size of the array, N.
  - If N is odd, initialize max and min as a[0] 
  - If N is even, set max and min as the maximum and minimum of a[0] and a[1]
  - For remaining elements in the array, take them as a pair.
  - Update max and min value to the maximum and minimum of the pair.
  - Time: O(n)  

16. You are given an array of 0s and 1s in random order. Segregate 0s on left side and 1s on right side of the array.
  - Maintain two indexes. Initialize left index as 0 and right index as n-1.
  - Loop until left < right
    - Keep incrementing left index until 1 encountered
	- Keep decrementing right index until 0 encountered
	- Swap a[left] with a[right], increment left, decrement right
  - Time: O(n)

17. Given an array of integers, find out maximum difference between any two elements such that larger element appears after the smaller number in array.
  - Maintain two values, 1. minimum element found so far 2. max difference found so far.
  - Initialise min = a[0] and maxDiff = a[1] - a[0]
  - For every element from 1 to N-1
    - Update maxDiff, if maxDiff < a[i] - min
	- Update min, if a[i] < min
  - Time:O(n)
  
18. Union and Intersection of two sorted arrays
  Union
  - Maintain two indexes i for arr1 and j for arr2 
  - Initialise i = 0 and j = 0
  - Loop until i < m and j < n, where m is length of arr1 and n is length of arr2
    - if arr1[i] < arr2[j], add arr1[i] to result set, U. Increment i
    - if arr1[i] > arr2[j], add arr2[j] to U. Increment j
    - if arr1[i] == arr2[j], add any one to U and Increment both i and j
  - If i < m, Add the remaining elements of arr1 to U
  - If j < n, Add the remaining elements of arr2 to U
  - Set U holds the result
  - Time: O(m+n)
  
  Intersection
  - Maintain two indexes i for arr1 and j for arr2 
  - Initialise i = 0 and j = 0
  - Loop until i < m and j < n, where m is length of arr1 and n is length of arr2
    - if arr1[i] < arr2[j], then increment i
    - if arr1[i] > arr2[j], then increment j
  - if arr1[i] == arr2[j], add any one to result set U and increment both i and j
  - Set U holds the result
  - Time: O(m+n)

19. Union and intersection of two arrays
  Sorting 
  - Sort both the arrays. It takes O(mLogm + nLogn)
  - Use above steps for union and intersection for two sorted arrays
  
  Sorting and Searching
  Union
  - Initialize result set U as empty
  - Find the smaller of m and n and sort the smaller array
  - Add all the elements of sorted array to U
  - For every element x in larger array
    - Binary search x in smaller array. If x is not present, the add to U
  - Set U holds the result
  - Time: min[O(m+n Logm), O(m+n Logn)]
  
  Intersection
  - Initialize result set U as empty
  - Find the smaller of m and n and sort the smaller array
  - For every element x in larger array
    - Binary search x in smaller array. If x is present, the add to U
  - Set U holds the result
  - Time: min[O(m+n Logm), O(m+n Logn)]
   
20. Given a sorted array and a value x, the ceiling of x is the smallest element in array greater than or equal to x, 
    and floor is the greatest element smaller than or equal to x. Write efficient functions to find floor and ceiling of x.
  Ceil
  - If x is smaller than or equal to first element in array, then return a[0]
  - Else binary search of an index i such that x lies between a[i] and a[i+1]
    - If x is smaller than or equal to the first element, then return the first element
    - If x is greater than the last element, then return -1
	- Find the index of the middle element, say mid
	- if a[mid] == x, return mid
	- If x is greater than arr[mid], then either arr[mid + 1] is ceiling of x or ceiling lies in arr[mid+1...high]
	- If x is smaller than arr[mid], then either arr[mid] is ceiling of x or ceiling lies in arr[low...mid-1]
  - Time: O(Logn)
	
21. Given an array arr[] of n integers, construct a Product Array prod[] (of same size) such that 
   prod[i] is equal to the product of all the elements of arr[] except arr[i]
  - Maintain two arrays left[] and right[] of length same as arr[i]
  - Initially set left[0] as 1 and right[n-1] as 1
  - For every element in the array from index 1 to N-1, left[i] = left[i-1] * arr[i-1]
  - For every element in the array from index N-2 to 0, right[j] = right[j+1] * arr[j+1]
  - Construct the product array by multiplying left[i] and right[i], storing the result in prod[i]
  - Time:O(n) Space: O(n)
  
22. Given an array consisting of 0s, 1s and 2s, write a function that sorts A[], ie. put all 0s first, then all 1s and all 2s in last.
    Dutch National Flag problems
  - Maintain three values, left = 0, curr = 0, right = n-1
  - Loop until curr <= right
    - if a[curr] is 0, swap a[left] with a[curr]. Increment curr and left
	- else if a[curr] is 2, swap a[right] with a[curr]. Decrement right. Note curr is not incremented here
	- else, increment curr only
  - Time:O(n)
  
23. Given an unsorted array arr[0..n-1] of size n, find the minimum length subarray arr[s..e] 
    such that sorting this subarray makes the whole array sorted.
  - Scan the array from left to right, and find the index s such that, a[s] is greater than a[s+1]
  - Similarly, scan the array from right to left and find the index e such that, a[e] < a[e-1]
  - Now, we need to check whether sorting this subarray makes the complete array sorted
  - Find the minimum and maximum element in the subarray from indices s to e, say min and max
  - Find the first element, if there is any, in arr from 0 to s-1, which is greater than min.
    If found change the index of s to this element.
  - Find the last element, if there is any, in arr from e+1 to n-1, which is smaller than max.
    If found change the index of e to this element.
  - s and e holds the start and end of the subarray.
  - Time: O(n)
  
24. Given an array of n elements which contains elements from 0 to n-1, with any of these numbers appearing any number of times. 
    Find these repeating numbers in O(n) and using only constant memory space.
  - For every element in the array, from 0 to n-1,
    - Check the sign value at index abs(arr[i])
	- If its positive, then make it negative. arr[abs(arr[i])] = - arr[abs(arr[i])]
	- If its already negative, then abs(arr[i]) is a repetition
 - This will work only if the elements are in the range of 0 to n-1.
 - Time:O(n)

25. Equilibrium index of an array is an index such that the sum of elements at lower indexes is equal to the sum of elements at higher indexes. 
    For example, in an array A [-7, 1, 5, 2, -4, 3, 0]
    A[0] = -7, A[1] = 1, A[2] = 5, A[3] = 2, A[4] = -4, A[5] = 3, A[6]=0
    3 is an equilibrium index, because: A[0] + A[1] + A[2] = A[4] + A[5] + A[6]
  - Maintain, leftSum initially set to 0
  - For every element from 0 to n-1, find the total sum of all elements say, sum.
  - For every element from 0 to n-1, subract a[i] from sum. (now sum indicates the right sum)
    - If leftSum == sum, then i is an equilibrium index
    - add a[i] to leftSum
  - Time:O(n)

26. Rotate an NxN matrix by 90 degrees
  - Rotate the matrix in layers. Starting from Outermost circular layer, inner ciruclar layer and moving inwards
  - Move top edge to right edge, right edge to bottom edge, bottom edge to left edge and 
    left edge to top edge.
  - Loop for every layer from 0 to n/2 - 1
    - Maintain two values indicating the first and last boundary of the layer
	- Set first = layer; last = n - 1 - layer;
	- For every element i from first to last in the layer
	  - To pick the elements by reducing one from last after every iteration of i
	    we need to calculate offset = i - first
	  - Save the top; top = m[first][i]
	  - left to top; m[first][i] = m[last - offset][first]
	  - bottom to left; m[last - offset][first] = m[last][last - offset]
	  - right to bottom; m[last][last - offset] = m[i][last] 
	  - top to right; m[i][last] = top
  - Time:O(n^2)
 
27. Rotate an MxN matrix by 90 degress
  - when we rotate a source matrix of MxN, we get a target matrix of NxM
  - We do need a new additional space to store the target matrix
  - First row of source --> last column of target
  - Second row of source --> last but one column of target
  - last row of source --> first column of target
  - For every row r from 0 to m-1
    - For every column c from 0 to n-1
      - target[c][m-1-r] = source[r][c]	
  - Time:O(n^2)

28. Given an array, print the Next Greater Element (NGE) for every element. The Next greater Element for an element x is 
    the first greater element on the right side of x in array. Elements for which no greater element exist, next greater element as -1.
	ex:  Input array [4, 5, 2, 25] next greater element is {5, 25, 25, -1}
  - Push the first element to the stack
  - For every element from 1 to n-1
    - set next = a[i]
    - if stack is not empty, pop the stack, say element
	  - if popped element is smaller than next, then print the pair
	  - keep popping the stack while elements are smaller than next and stack is not empty
	  - if stack becomes emptpy while popping, or popped element is greater than next, 
	    push element to stack 
	- if stack is empty push next to stack
  - Time:O(n) Space:O(n)

29. Given an unsorted array of numbers, write a function that returns true if array consists of consecutive numbers.
    Examples:
    a) If array is {5, 2, 3, 1, 4}, then the function should return true because the array has consecutive numbers from 1 to 5.
    b) If array is {83, 78, 80, 81, 79, 82}, then the function should return true because the array has consecutive numbers from 78 to 83.
    c) If the array is {34, 23, 52, 12, 3 }, then the function should return false because the elements are not consecutive.
    d) If the array is {7, 6, 5, 5, 3, 4}, then the function should return false because 5 and 5 are not consecutive.
  - The idea is to check for following two conditions. If following two conditions are true, then return true.
    1. max – min + 1 = n where max is the maximum element in array, min is minimum element in array and n is the number of elements in array.
    2. All elements are distinct.
	- To check all the elemements are distinct, maintain a visited array of length n. map the ith element in the array to the visited[a[i] - min]
  - Time: O(n) Space:O(n)

30. Given a sorted array of n integers where each integer is in the range from 0 to m-1 and m > n. 
    Find the smallest number that is missing from the array.
	Examples
	Input: {0, 1, 2, 6, 9}, n = 5, m = 10
	Output: 3
	Input: {4, 5, 10, 11}, n = 4, m = 12
	Output: 0
	Input: {0, 1, 2, 3}, n = 4, m = 5
	Output: 4
	Input: {0, 1, 2, 3, 4, 5, 6, 7, 10}, n = 9, m = 11
	Output: 8
  - In the standard Binary Search process, the element to be searched is compared with the middle element and on the basis of comparison result, 
    we decide whether to search is over or to go to left half or right half.
  - In this method, we modify the standard Binary Search algorithm to compare the middle element with its index and make decision on the basis of this comparison.
  - If the first element is not same as its index then return first index
  - Else get the middle index say mid
	 a) If arr[mid] greater than mid then the required element lies in left half.
	 b) Else the required element lies in right half.
  - Time: O(Logn) 
  - Note: This doesn’t work if there are duplicate elements in the array.

31. Given a sorted array arr[] and a number x, write a function that counts the occurrences of x in arr[].
	Input: arr[] = {1, 1, 2, 2, 2, 2, 3,},   x = 2
	Output: 4 // x (or 2) occurs 4 times in arr[]
	Input: arr[] = {1, 1, 2, 2, 2, 2, 3,},   x = 3
	Output: 1 
	Input: arr[] = {1, 1, 2, 2, 2, 2, 3,},   x = 1
	Output: 2 
	Input: arr[] = {1, 1, 2, 2, 2, 2, 3,},   x = 4
	Output: -1 // 4 doesn't occur in arr[] 
  - Use Binary search to get index of the first occurrence of x in arr[]. Let the index of the first occurrence be i
    -  if( ( mid == 0 || x > arr[mid-1]) && arr[mid] == x)
		  return mid;
		else if(x > arr[mid])
		  return first(arr, (mid + 1), high, x, n);
		else
		  return first(arr, low, (mid -1), x, n);
  - Use Binary search to get index of the last occurrence of x in arr[]. Let the index of the last occurrence be j.
	- if( ( mid == n-1 || x < arr[mid+1]) && arr[mid] == x )
		return mid;
	  else if(x < arr[mid])
        return last(arr, low, (mid -1), x, n);
      else
         return last(arr, (mid + 1), high, x, n); 
  - Return (j – i + 1); 
  - Time: O(Logn)

32. Given an array arr[], find the maximum j – i such that arr[j] > arr[i]
  - Construct two auxiliary arrays LMin[] and RMax[] such that 
    LMin[i] holds the smallest element on left side of arr[i] including arr[i], and 
	RMax[j] holds the greatest element on right side of arr[j] including arr[j]. 
  - Maintain two pointers i, j for LMin and RMax respectively and maxDiff = 0
  - Loop while i<n and j<n-1
    - if LMin[i] < RMax[j]
	  - Update maxDiff, if j-i is greater than maxDiff
	  - Increment j
	else 
	  - Increment i
  - Time: O(n) Space:O(n)

33. Given two arrays: arr1[0..m-1] and arr2[0..n-1]. Find whether arr2[] is a subset of arr1[] or not. Both the arrays are not in sorted order.
	Examples:
	Input: arr1[] = {11, 1, 13, 21, 3, 7}, arr2[] = {11, 3, 7, 1}
	Output: arr2[] is a subset of arr1[]
	Input: arr1[] = {1, 2, 3, 4, 5, 6}, arr2[] = {1, 2, 4}
	Output: arr2[] is a subset of arr1[]
	Input: arr1[] = {10, 5, 2, 23, 19}, arr2[] = {19, 5, 3}
	Output: arr2[] is not a subset of arr1[]
	Sorting & searching
  - Sort the first array arr1
  - For every element in arr2, do binary search in sorted array arr1
  - If the element i is not found then return false
  - If all elements are present then return true
  - Time: O(mLogm + nLogm) 
          mLogm - for sorting algorithm. nLogm - to binary search n elements in array of size m 
          
	
	Sorting & merging
  - Sort both the arrays arr1 and arr2
  - Use merge type method to see if all elements of arr2 is present in arr1	
  - Time: O(mLogm + nLogn)
          mLogm - sort arr1, nLogn - sort arr2
		  
34. Given an unsorted array arr[] and two numbers x and y, find the minimum distance between x and y in arr[]. 
    The array might also contain duplicates. You may assume that both x and y are different and present in arr[].
    Examples:
	Input: arr[] = {1, 2}, x = 1, y = 2
	Output: Minimum distance between 1 and 2 is 1.
	Input: arr[] = {3, 4, 5}, x = 3, y = 5
	Output: Minimum distance between 3 and 5 is 2.
	Input: arr[] = {3, 5, 4, 2, 6, 5, 6, 6, 5, 4, 8, 3}, x = 3, y = 6
	Output: Minimum distance between 3 and 6 is 4.
	Input: arr[] = {2, 5, 3, 5, 4, 4, 2, 3}, x = 3, y = 2
	Output: Minimum distance between 3 and 2 is 1.
  - Traverse the array from left to right and stop if either x or y is found.
  - Store the index of this first occurrence in a variable say prev.
  - Maitain the minDist value and initially set to MAX_VALUE
  - Traverse the array from  i = prev to n-1 to find for either x or y
    - If found, and if current element is different from prev element  
	 and if this distance (i-prev)value is smaller than minimm distance so far, update minDist
	- If the current is same as prev element, update prev index to i
  - Finally return the minDist
  - Time: O(n)

35. Given an array A[0 … n-1] containing n positive integers, a subarray A[i … j] is bitonic 
    if there is a k with i <= k <= j such that A[i] <= A[i + 1] ... <= A[k] >= A[k + 1] >= .. A[j – 1] > = A[j]. 
	Write a function that takes an array as argument and returns the length of the maximum length bitonic subarray.
	Simple Examples
	1) A[] = {12, 4, 78, 90, 45, 23}, the maximum length bitonic subarray is {4, 78, 90, 45, 23} which is of length 5.
	2) A[] = {20, 4, 1, 2, 3, 4, 2, 10}, the maximum length bitonic subarray is {1, 2, 3, 4, 2} which is of length 5.
	Extreme Examples
	1) A[] = {10}, the single element is bitnoic, so output is 1.
	2) A[] = {10, 20, 30, 40}, the complete array itself is bitonic, so output is 4.
	3) A[] = {40, 30, 20, 10}, the complete array itself is bitonic, so output is 4.
  - Construct an auxiliary array inc[] from left to right such that inc[i] contains length of the nondecreaing subarray ending at arr[i].
	For for A[] = {12, 4, 78, 90, 45, 23}, inc[] is {1, 1, 2, 3, 1, 1}
  - Construct another array dec[] from right to left such that dec[i] contains length of nondecreasing subarray starting at arr[i].
	For A[] = {12, 4, 78, 90, 45, 23}, dec[] is {2, 1, 1, 3, 2, 1}.
  - Once we have the inc[] and dec[] arrays, all we need to do is find the maximum value of (inc[i] + dec[i] – 1).
	For {12, 4, 78, 90, 45, 23}, the max value of (inc[i] + dec[i] – 1) is 5 for i = 3.
  - Time:O(n) Space:O(n)

36. Given an array of integers which is initially increasing and then decreasing, find the maximum value in the array.
	Input: arr[] = {8, 10, 20, 80, 100, 200, 400, 500, 3, 2, 1}
	Output: 500
	Input: arr[] = {1, 3, 50, 10, 9, 7, 6}
	Output: 50
	Corner case (No decreasing part)
	Input: arr[] = {10, 20, 30, 40, 50}
	Output: 50
	Corner case (No increasing part)
	Input: arr[] = {120, 100, 80, 20, 0}
	Output: 120
  - Its a variation of binary search
  - If the middle element is greater than both its adjacents, ie a[mid-1] < a[mid] > a[mid+1], then middle element is the result
  - If the middle element is greater the previous element and smaller than the next element, then search in right side of the middle element
  - If the middle element is smaller than the previous element and greater than the next element, then search in left side of middle element
  - Base cases:
    - Only one element is present in arr[low..high]
	  if (low == high)
        return arr[low];
    - If there are two elements and first is greater, then the first element is result
	- If there are two elements and second is greater then the second element is result

37. Implement two stacks in an array
  - Maintain two stacks at the two extreme ends of the arr[]
  - stack1 grows from 0 to n-1, first element in stack1 is pushed at index 0, then 1, 2, etc
  - Initial value of top1 is -1
  - stack2 grows from n-1 to 0, first element in stack2 is pushed at index n-1, then n-2, n-3 etc
  - Initial value of top2 is n
  - Push1: if (top1 < top2 - 1) then, increment top1 and insert at index pointed by top1 
           else stack overflow
  - Push2: if (top1 < top2 - 1) then, decrement top2 and insert at index pointed by top2
           else stack overflow
  - Pop1: if (top1 >= 0) return a[top1] and decrement top1
          else stack underflow
  - Pop2: if (top2 < size) return a[top2] and increment top2
          else stack underflow
  - Time: O(1) for all four operations

38. Implement K stacks in an array
  - Maintain two arrays, top, next and value free:
    - top[]: size k and stores indexes of top elements in all stacks. 
	  All entries in top[] are initialized as -1 to indicate that all stacks are empty.
	- next[]: size n and stores the indexes of next item for the items in array arr[]
	  All entries next[i] are initialized as i+1 because all slots are free initially and pointing to next slot. 
	  Last slot in next array is set to -1, indicating end of free list
	- free: integer, stores the index of next available free slot. Initially set to 0
	        -1 in free indicates the end of free list hence all stacks are full.
  - Push(int item, int stackNumber): 
    - if free is -1, stack overflow return
	- Store the index of next free slot in a temp variable, i = free
	- Update the index of next free slot to index of next slot, free = next[i]
	- Make next[i] points FROM next available position TO previous occupied position of that stack.
	  next[i] = top[stackNumber]
	- Update the top of stack to point to current item index, top[stackNumber] = i
	- Put the item in the array, a[i] = item
  - Pop(int stackNumber)
    - if top[stackNumber] is -1, then stack underflow return
	- Get the index of the top element of the stack into i = top[stackNumber]
	- Update top to the previously inserted index, top[stackNumber] = next[i]
	- Make next[i] points FROM previous occupied position of that stack TO next available position.
	  next[i] = free;
	- Update free to the current top index, free = i
	- Return the item a[i]
  - Time: push & pop is O(1)

39. Find subarray with given sum
    Given an unsorted array of nonnegative integers, find a continous subarray which adds to a given number.
    Examples:
	Input: arr[] = {1, 4, 20, 3, 10, 5}, sum = 33
	Ouptut: Sum found between indexes 2 and 4
	Input: arr[] = {1, 4, 0, 0, 3, 10, 5}, sum = 7
	Ouptut: Sum found between indexes 1 and 4
	Input: arr[] = {1, 4}, sum = 0
	Output: No subarray found  
  - Maintain two values 
    currSum: indicates the sum of the current sub array. Initially set to a[0]
	start: start indicates the starting index of the current sub array. Initially set to 0.
  - For every element from 1 to n-1, 
    - Keep adding a[i] to currSum
	- when currSum exceeds sum, remove the starting elements by using start variable while 
	  currSum is greater than sum and start < i-1 
	  - currSum = currSum - a[start];
	    start++;
  - Time:O(n)
  
40. Given an array and a value, find if there is a triplet in array whose sum is equal to the given value. 
    If there is such a triplet present in array, then print the triplet and return true. Else return false. 
	eg, if the given array is {12, 3, 4, 1, 6, 9} and given sum is 24, then there is a triplet (12, 3 and 9)
  - Sort the input array
  - Fix the first element as a[i] where i = 0 to n-3
    - Find other two elements by having indexes at two ends of the array 
	  left = i+1, right = n-1
	- if a[i] + a[left] + a[right] == sum print them
	- else if a[i] + a[left] + a[right] < sum, increment left
	- else increment right
  - Time:O(n^2)
  
41. Find four elements that sum to a given value | O(n^3)
	Given an array of integers, find all combination of four elements in the array whose sum is equal to a given value X.
	For example, if the given array is {10, 2, 3, 4, 5, 9, 7, 8} and X = 23, then your function should print “3 5 7 8″ (3 + 5 + 7 + 8 = 23).  
  - Sort the input array
  - Fix the first element as a[i] where i = 0 to n-3
    - Fix the second element as a[j] where j = i+1 to n-20
	  - Find other two elements by having indexes at two ends of the array 
		  left = j+1, right = n-1
	  - if a[i] + a[j] + a[left] + a[right] == sum print them
	  - else if a[i] + a[j] + a[left] + a[right] < sum, increment left
	  - else increment right
  - Time:O(n^3)

42. Find four elements that sum to a given value | O(n^2 Logn)
	Given an array of integers, find all combination of four elements in the array whose sum is equal to a given value X.
	For example, if the given array is {10, 2, 3, 4, 5, 9, 7, 8} and X = 23, then your function should print “3 5 7 8″ (3 + 5 + 7 + 8 = 23).
  - Let the input array be A[]. Create an auxiliary array aux[] and store sum of all possible pairs in aux[]. 
    The size of aux[] will be n*(n-1)/2 where n is the size of A[].
  - Sort the auxiliary array aux[].
  - Now the problem reduces to find two elements in aux[] with sum equal to X. 
  - We can use two element sum pointer technique to find the two elements.
  - An element of aux[] represents a pair from A[]. While picking two elements from aux[], 
    we must check whether the two elements have an element of A[] in common. 
	For example, if first element sum of A[1] and A[2], and second element is sum of A[2] and A[4], 
	then these two elements of aux[] don’t represent four distinct elements of input array A[].
  - Time:O(n^2 Logn)
  
43. Given an array of n integers, find the 3 elements such that a[i] < a[j] < a[k] and i < j < k in 0(n) time. 
    If there are multiple such triplets, then print any one of them.
  - Maintain two arrays smaller, greater of size n
  - smaller[i] should store the index of the number which is smaller than arr[i] and is on the left side of arr[i]
    smaller[i] should  contain -1 if there is no such element.
	- Set smaller[0] to -1 and min = 0
	- For every element from 1 to n-1
	  - if (arr[i] <= arr[min]) then min = i; smaller[i] = -1;
	    else smaller[i] = min
  - greater[i] should store the index of a number which is greater than arr[i] and is on right side of arr[i]. 
    greater[i] should contain -1 if there is no such element.
	- Set greater[n-1] to -1 and max = n-1
	- For every element from n-2 to 0
	  - if (arr[i] >= arr[max]) max = i; greater[i] = -1
	    else greater[i] = max
  - Finally traverse both smaller[] and greater[] and find the index i for which both smaller[i] and greater[i] are not -1.
  - Time:O(n) Space:O(n)


44. Given an array of integers, replace every element with the next greatest element (greatest element on the right side) in the array. 
    Since there is no element next to the last element, replace it with -1. 
	eg, if the array is {16, 17, 4, 3, 5, 2}, then it should be modified to {17, 5, 5, 5, 2, -1}.
  - Its similar to the leader problem.
  - Initialize max = a[n-1]
  - Traverse the array from right to left, i = n-2 to 0
    - Save the current element in temp = a[i]
	- Set current element to the greatest element to the right, a[i] = max
	- Update max if temp > max, max = temp
  - O(n)

45. Given an array of integers where each element represents the max number of steps that can be made forward from that element. 
    Write a function to return the minimum number of jumps to reach the end of the array (starting from the first element). 
	If an element is 0, then cannot move through that element.
	Example:
	Input: arr[] = {1, 3, 5, 8, 9, 2, 6, 7, 6, 8, 9}
	Output: 3 (1-> 3 -> 8 ->9)
	First element is 1, so can only go to 3. Second element is 3, so can make at most 3 steps eg to 5 or 8 or 9.
	Method1: Top Down approach
  - jumps[i] -> minimum number of jumps to reach a[i] from a[0]
  - Initially set jumps[0] = 0
  - Intention is to fill jumps array and finally jumps[n-1] holds the result
  - For every element in array i from 1 to n-1
    - jumps[i] = INT_MAX
	- For every element j from 0 to i-1
      - if i is reachable from j, ie i <= j + a[j] and a[j] is not INT_MAX
        - Assign jumps[i] as Minimum between jumps[i] and jumps[j] + 1
  - Finally return jumps[n-1]
  - Time: O(n^2)

46. Longest increasing subsequence
    The longest Increasing Subsequence (LIS) problem is to find the length of the longest subsequence of a given sequence 
	such that all elements of the subsequence are sorted in increasing order. 
	eg, length of LIS for { 10, 22, 9, 33, 21, 50, 41, 60, 80 } is 6 and LIS is {10, 22, 33, 50, 60, 80}
  - lis[i] -> contains the length of the longest increasing subsequence from a[0] till a[i]
  - Objective is to fill list array and finally maximum value of lis[i] is the result 
  - Initially set all elements of lis[i] to 1, meaning considering the element a[i] alone for the subsequence
  - For every element i from 1 to n-1
    - For every element j from 0 to i-1
      - If element at index i is greater than element at index j and
        length of lis to reach i is less than length of lis to reach j + 1, then set 
		length of lis to reach i to length of lis to reach j + 1
		if (a[i] > a[j] && lis[i] < lis[j] + 1) then lis[i] = lis[j] + 1
  - Return the maximum value of lis[i]
  - Time:O(n^2)

47. Maximum Sum Increasing Subsequence
    Given an array of n positive integers. Write a program to find the sum of maximum sum subsequence of the given array 
	such that the intgers in the subsequence are sorted in increasing order. 
	eg, if input is {1, 101, 2, 3, 100, 4, 5}, then output should be 106 (1 + 2 + 3 + 100), 
	if the input is {3, 4, 5, 10}, then output is 22 (3 + 4 + 5 + 10) and if input is {10, 5, 4, 3}, then output should be 10
  - Its a variation of LIS. Instead of length of subsequence, we need to maintain the sum of increasing subsequence
  - msis[i] -> contains the maximum sum of increasing subsequence from a[0] till a[i]
  - Objective is to fill msis array and finally maximum value in msis is the result
  - Initially set all elements of msis[i] to a[i], meaning considering the element a[i] alone for the subsequence
  - For every element i from 1 to n-1
    - For every element j from 0 to i-1
	  - If element at index i is greater than element at index j and
        sum of lis till i is less than sum of lis till j + a[i], then set 
		sum of lis till i to sum of lis till reach j + a[i]
		if (a[i] > a[j] && msis[i] < msis[j] + a[i]) then msis[i] = msis[j] + a[i]
  - Return the maximum value in msis[i]
  - Time:O(n^2) 

48. Longest Bitonic Subsequence
    Given an array arr[0 … n-1] containing n positive integers, a subsequence of arr[] is called Bitonic if it is first increasing, then decreasing. 
	Write a function that takes an array as argument and returns the length of the longest bitonic subsequence.
	Input arr[] = {1, 11, 2, 10, 4, 5, 2, 1};
	Output: 6 (A Longest Bitonic Subsequence of length 6 is 1, 2, 10, 4, 2, 1)
	Input arr[] = {12, 11, 40, 5, 3, 1}
	Output: 5 (A Longest Bitonic Subsequence of length 5 is 12, 11, 5, 3, 1)
	Input arr[] = {80, 60, 30, 40, 20, 10}
	Output: 5 (A Longest Bitonic Subsequence of length 5 is 80, 60, 30, 20, 10)
  - Its a variation of LIS. We need to build two arrays, lis[i] and lds[i]
  - lis[i] -> stores the length of lis from a[0] to a[i]
  - lds[i] -> stores the lenth of longest decreasing subsequence starting from a[i] to a[n-1]
  - Maximum value of lis[i] + lds[i] -1 is the result
  - Build lds: Initially set lds[i] = 1 
    - For every element i from n-2 to 0 
	  - For every element j from n-1 to i-1
	    - If element at index i is greater than element at index j and
          length of lds from i is less than length of lds from j + 1, then set 
		  length of lds from i to length of lds from reach j + 1
		  if (a[i] > a[j] && lds[i] < lds[j] + 1) then lds[i] = lds[j] + 1 
  - Time:O(n^2)

49. Maximum Length Chain of Pairs
	You are given n pairs of numbers. In every pair, the first number is always smaller than the second number. 
	A pair (c, d) can follow another pair (a, b) if b < c. Chain of pairs can be formed in this fashion. 
	Find the longest chain which can be formed from a given set of pairs. 
	For example, if the given pairs are {{5, 24}, {39, 60}, {15, 28}, {27, 40}, {50, 90} }, 
	then the longest chain that can be formed is of length 3, and the chain is {{5, 24}, {27, 40}, {50, 90}}
  - This is a variation of LIS
  - mcl[i] -> contains the maximum chain length ending at a[i]
  - a[i] contains the given pairs sorted by the first element. Its size is n
  - Now run lis where we compare the first element of new element with the second element of already constructed mcl
    if ( arr[i].a > arr[j].b && mcl[i] < mcl[j] + 1)
            mcl[i] = mcl[j] + 1;
  - Return the maximum value in msis[i]
  - Time:O(n^2)

50. Longest Monotonically Increasing Subsequence NlogN
  - We need to maintain set of active 
  - If A[i] is smallest among all end candidates of active lists, we will start new active list of length 1.
  - If A[i] is largest among all end candidates of active lists, we will clone the largest active list, and extend it by A[i].
  - If A[i] is in between, we will find ceiling element to A[i] & replace it. Clone and extend this list by A[i]. 
  - tailIndices[i] : array of size n, to keep the index of tail elements ie. subsequence ending with this element
  - prevIndices[i] : array of size n, to keep track of previous element index in the subsequence. Required to finally print the lis
  - len : an integer to keep track of the longest subsequence so far.
  - Initially set tailIndices[0] = 0 and prevIndices[0] = -1 and len=1;
  - For every element i in the array a[] from 1 to n-1
    - if a[i] is smaller than a[0], replace the smallest value, ie tailIndices[0] = i
	- else if a[i] is bigger than a[len-1], extend largest subsequence, ie tailIndices[len++] = i.
	  - Before extending the subsequence capture the previous element index by prevIndices[i] = tailIndices[len-1]
	- else if a[i] is in between a[0] and a[len-1], find the ceil index tail end elements
      - Replace the ceil tail element with a[i]
      - Capture the previous element index, prevIndices[i] = tailIndices[pos-1]
  - Print the subsequence starting with tailIndices[len-1] and navigating with prevIndices[i]
  - Time: O(NlogN)

51. Maximum product subarray
  - Maintain three arrays of size n, positiveProducts[i], negativeProducts[i], maxProducts[i] 
  - Initially set positiveProducts[0] = a[0], negativeProducts = a[0], maxProducts = a[0] 
  - For every element i from 1 to n-1
    - int currPositive = positiveProducts[i-1] * a[i]  
	- int currNegative = negativeProducts[i-1] * a[i]
	- positiveProducts[i] = max(max(currPositive, currNegative), a[i])
	- negativeProducts[i] = min(min(currPositive, currNegative), a[i])
	- maxProducts[i] = max(maxProducts[i-1], positiveProducts[i])
  - Finally maxProducts[n-1] holds the result.
  
52. Find if there is a subarray with 0 sum
	Given an array of positive and negative numbers, find if there is a subarray (of size at-least one) with 0 sum.
	Examples:
	Input: {4, 2, -3, 1, 6}	Output: true 
	There is a subarray with zero sum from index 1 to 3. Input: {4, 2, 0, 1, 6} Output: true 
	There is a subarray with zero sum from index 2 to 2. Input: {-3, 2, 3, 1, 6} Output: false
	There is no subarray with zero sum.
  - The idea is to iterate through the array and for every element arr[i], calculate sum of elements form 0 to i. 
    If the current sum has been seen before, then there is a zero sum array. 
	Hashing is used to store the sum values, so that we can quickly store sum and find out whether the current sum is seen before or not.
  - Maintain a hashmap<Integer, Integer> with sum, i as key value pair.
  - For every element i from 0 to n-1
    - Add current element to sum
    - Return true, if current element is 0, or sum is 0 or this sum has been seen before.
  - Time: O(n)

53. Pythagorean Triplet in an array
	Given an array of integers, write a function that returns true if there is a triplet (a, b, c) that satisfies a2 + b2 = c2.
	Example:
	Input: arr[] = {3, 1, 4, 6, 5} Output: True There is a Pythagorean triplet (3, 4, 5).
	Input: arr[] = {10, 4, 6, 12, 5} Output: False  There is no Pythagorean triplet.
  - Do square of every element in input array. This step takes O(n) time.
  - Sort the squared array in increasing order. This step takes O(nLogn) time.
  - To find a triplet (a, b, c) such that a = b + c, do following.
    - Fix 'a' as last element of sorted array.
    - Now search for pair (b, c) in subarray between first element and 'a'. 
	  A pair (b, c) with given sum can be found in O(n) time using meet in middle algorithm.
    - If no pair found for current 'a', then move 'a' one position back and repeat step 3.b.
  - Time:O(n^2)

54. Find the largest pair sum in an unsorted array
    Given an unsorted of distinct integers, find the largest pair sum in it. For example, the largest pair sum in {12, 34, 10, 6, 40} is 74.
  - Initialize both first and second largest elements to the biggest and smallest of first two elements
    first = max(arr[0], arr[1])
    second = min(arr[0], arr[1])
  - For every element i from 2 to n-1
    - If the current element is greater than first, then update first and second. 
    - Else if the current element is greater than second then update second
  - Sum of first and second is the result
  - Time:O(n)

55. Stock problem, if we are allowed to buy and sell only once OR
    Maximum difference between two elements such that larger element appears after the smaller number
    Given an array arr[] of integers, find out the difference between any two elements such that larger element appears after the smaller number in arr[].
    If array is [2, 3, 10, 6, 4, 8, 1] then result is 8 (Diff between 10 and 2). 
	If array is [ 7, 9, 5, 6, 3, 2 ] then returned is 2 (Diff between 7 and 9)
  - We take the maximum difference with the minimum element found so far.
  - Maintain two values, minElement: minimum element found so far; maxDiff: maximum difference found so far
  - Initially set minElement to the first element and maxDiff as 0
  - For every element i from 1 to n-1
    - Check and update minElement, if a[i] is smaller than minElement
	- Check and update maxDiff, if the difference between minElement and a[i] is higher than maxDiff
  - Finally maxDiff holds the result
  - Time: O(n)
  
56. Maximum profit by buying and selling a share at most twice.	In a daily share trading, a buyer buys shares in the morning and sells it on same day. 
    If the trader is allowed to make at most 2 transactions in a day, where as second transaction can only start after first one is complete (Sell->buy->sell->buy). 
	Given stock prices throughout day, find out maximum profit that a share trader could have made.
	Examples:
	Input:   price[] = {10, 22, 5, 75, 65, 80}
	Output:  87
	Trader earns 87 as sum of 12 and 75
	Buy at price 10, sell at 22, buy at 5 and sell at 80
	Input:   price[] = {2, 30, 15, 10, 8, 25, 80}
	Output:  100
	Trader earns 100 as sum of 28 and 72
	Buy at price 2, sell at 30, buy at 8 and sell at 80
	Input:   price[] = {100, 30, 15, 10, 8, 25, 80};
	Output:  72
	Buy at price 8 and sell at 80.
	Input:   price[] = {90, 80, 70, 60, 50}
	Output:  0
	Not possible to earn.
  - Maintain an array profit[i] of size n, which stores the maximum profit of every subarray
  - Initially set all values in profit[i] as 0
  - Traverse price[] from right to left and update profit[i] such that profit[i] stores maximum profit achievable from one transaction in subarray price[i..n-1]
    - Set maxPrice as last element, price[n-1]
	- For every element from n-2 to 0, 
	  - update maxPrice if price[i] is higher than maxPrice
	  - Set profit[i] as Maximum of profit[i+1] or maxPrice - price[i]
  - Traverse price[] from left to right and update profit[i] such that profit[i] stores maximum profit 
    such that profit[i] contains maximum achievable profit from two transactions in subarray price[0..i].
	- Set minPrice as first element, price[0]
	- For every element from 1 to n-1, 
	  - update minPrice if price[i] is lesser than minPrice
	  - Set profit[i] as Maximum of profit[i-1] or profit[i] + price[i] - minPrice
  - Finally profit[n-1] holds the result
  - Time:O(n) SpaceO(n)
  
57. Stock Buy Sell to Maximize Profit
	The cost of a stock on each day is given in an array, find the max profit that you can make by buying and selling in those days. 
	For example, if the given array is {100, 180, 260, 310, 40, 535, 695}, the maximum profit can earned by buying on day 0, selling on day 3. 
	Again buy on day 4 and sell on day 6. If the given array of prices is sorted in decreasing order, then profit cannot be earned at all.
  - Find the local minima and store it as starting index. If not exists, return.
  - Find the local maxima. and store it as ending index. If we reach the end, set the end as ending index.
  - Update the solution (Increment count of buy sell pairs)
  - Repeat the above steps if end is not reached.
  - Time:O(n)

58. The Stock Span Problem
	The stock span problem is a financial problem where we have a series of n daily price quotes for a stock and 
	we need to calculate span of stock’s price for all n days. The span Si of the stock’s price on a given day i is defined 
	as the maximum number of consecutive days just before the given day, for which the price of the stock on the current day 
	is less than or equal to its price on the given day.
	If an array of 7 days prices is given as {100, 80, 60, 70, 60, 75, 85}, then the span values for corresponding 7 days are {1, 1, 1, 2, 1, 4, 6}
  - Idea is to maintain a stack and store the days.
  - When we traverse from day i-1 to i, we pop the days when the price of the stock was less than or equal to price[i] and 
    then push the value of day i back into the stack.
  - Create a stack and push index of first element to it
  - Maintain a array span[i] of length n; Span value of first element is always 1
  - For every element i from 1 to n-1
    - Pop elements from stack while stack is not empty and top of stack is smaller or equal to than price[i]
	- If stack becomes empty, then price[i] is greater than all elements on left of it, i.e., price[0], price[1],..price[i-1].  
	  so span[i] = number of days form the beginning which is i+1
    - Else price[i] is greater than elements after top of stack
	  so span[i] = number of days after top price which is i - stack.peek();
  - Time:O(n)
	
59. Delete an element from array in one traversal
  - Assumption: element to be deleted is present in the array.
  - Start from the rightmost element and keep moving the element one position ahead
    until we find x.
    - While moving we need to remember the value in the index in which we will be writing
	  the moving element.
	- Maintain a variable called prev which will store this value. Initially set it to a[n-1]
	- For every element i from n-2 to 0 
	  - Set temp = a[i]
	  - Set a[i] = prev 
	  - Assign prev = temp;
	- Do the above step until either start of the array is reached or the element x is found.
	- If start is found, x is not present in the array.
	- If element x is found at index i, then set a[i] = prev.
  - Time:O(n)

60. Replace every array element by multiplication of previous and next
	Given an array of integers, update every element with multiplication of previous and next elements with following exceptions. 
	a) First element is replaced by multiplication of first and second.
	b) Last element is replaced by multiplication of last and second last.
	Input: arr[] = {2, 3, 4, 5, 6}
	Output: arr[] = {6, 8, 15, 24, 30} // arr[] = {2*3, 2*4, 3*5, 4*6, 5*6} 
  - Idea is to calculate result for first and last element separately out of loop.
  - For middle elements, keep track of previous element and find the product of prev and a[i+1]
  - Initially set prev = a[0]
  - Find the product for first element, a[0] = prev * a[1]
  - For every element i from 1 to n-2
    - Set curr = a[i]
	- a[i] = prev * a[i+1]
	- prev = curr
  - After Loop ends, we need to calculate for the last element as a[n-1] = prev * a[n-1]
  - Time: O(n)
	
61. Check if any two intervals overlap among a given set of intervals
	An interval is represented as a combination of start time and end time. Given a set of intervals, check if any two intervals overlap.
	Input:  arr[] = {{1,3}, {5,7}, {2,4}, {6,8}}
	Output: true
	The intervals {1,3} and {2,4} overlap
	Input:  arr[] = {{1,3}, {7,9}, {4,6}, {10,13}}
	Output: false
	No pair of intervals overlap.  
  - Sort all intervals in increasing order of start time. This step takes O(nLogn) time.
  - In the sorted array, if start time of an interval is less than end of previous interval, then there is an overlap. This step takes O(n) time.
  - Time: O(nLogn) + O(n) which is O(nLogn).

62. Check if a given array contains duplicate elements within k distance from each other
	Given an unsorted array that may contain duplicates. Also given a number k which is smaller than size of array. 
	Write a function that returns true if array contains duplicates within k distance.
	Examples:
	Input: k = 3, arr[] = {1, 2, 3, 4, 1, 2, 3, 4}
	Output: false
	All duplicates are more than k distance away.
	Input: k = 3, arr[] = {1, 2, 3, 1, 4, 5}
	Output: true
	1 is repeated at distance 3.
	Input: k = 3, arr[] = {1, 2, 3, 4, 5}
	Output: false
	Input: k = 3, arr[] = {1, 2, 3, 4, 4}
	Output: true
  - Maintain a hashset.
  - For every element i 0 to n-1 
    - If a[i] is present in the hashtable, then we found a duplicate element within k distance
	- Else add a[i] to hashtable. Also,remove a[i-k] element from hashset, if i is greater than or equal  to keep
  - Time: O(n)

63. Find position of an element in a sorted array of infinite numbers
  -	Since array is sorted, the first thing clicks into mind is binary search, but the problem here is that we don’t know size of array.
  -	Since the array is infinite, we don’t have the upper limit to apply binary search. We need to identify the upper limit first
  -	Let low be pointing to 1st element and high pointing to 2nd element of array, Now compare key with high index element,
    - if it is greater than high index element then copy high index in low index and double the high index.
	- if it is smaller, then apply binary search on high and low indices found.
  - Time: O(Log p)  Let p be the position of element to be searched. 
    Number of steps for finding high index 'h' is O(Log p). The value of 'h' must be less than 2*p. 
	The number of elements between h/2 and h must be p. Therefore, time complexity of Binary Search step is also O(Log p) 
	and overall time complexity is 2*O(Log p) which is O(Log p).

64. Find the smallest positive integer value that cannot be represented as sum of any subset of a given array
	Given a sorted array (sorted in non-decreasing order) of positive numbers, find the smallest positive integer value that 
	cannot be represented as sum of elements of any subset of given set. 
	Expected time complexity is O(n).
	Examples:
	Input:  arr[] = {1, 3, 6, 10, 11, 15};
	Output: 2
	Input:  arr[] = {1, 1, 1, 1};
	Output: 5
	Input:  arr[] = {1, 1, 3, 4};
	Output: 10
	Input:  arr[] = {1, 2, 5, 10, 20, 40};
	Output: 4
	Input:  arr[] = {1, 2, 3, 4, 5, 6};
	Output: 22
  - Initialise result 'res'  as 1, the smallest possible integer.
  - For every element i from 0 to n-1, 
    - We decide that 'res' is the final result: If arr[i] is greater than 'res', 
	  then we found the gap which is 'res' because the elements after arr[i] are also going to be greater than 'res'.
    - The value of 'res' is incremented after considering arr[i]: The value of 'res' is incremented by arr[i] 
	  (If elements from 0 to (i-1) can represent 1 to 'res-1', then elements from 0 to i can represent from 1 to 'res + arr[i] – 1 
	  by adding 'arr[i]' to all subsets that represent 1 to 'res'
  - Time:O(n)

65. Find the first repeating element in an array of integers
	Given an array of integers, find the first repeating element in it. 
	We need to find the element that occurs more than once and whose index of first occurrence is smallest.
	Examples:
	Input:  arr[] = {10, 5, 3, 4, 3, 5, 6}
	Output: 5 [5 is the first element that repeats]
	Input:  arr[] = {6, 10, 5, 4, 9, 120, 4, 6, 10}
	Output: 6 [6 is the first element that repeats]
  - Traverse the given array from right to left and keep adding to a hashtable
  - Before adding check if the element has been already found. If found, capture the index as minIndex.
  - Finally, minIndex holds the result value.
  - Time:O(n)

66. Find common elements in three sorted arrays
	Given three arrays sorted in non-decreasing order, print all common elements in these arrays.
	Examples:
	ar1[] = {1, 5, 10, 20, 40, 80} ar2[] = {6, 7, 20, 80, 100} ar3[] = {3, 4, 15, 20, 30, 70, 80, 120} Output: 20, 80
	ar1[] = {1, 5, 5} ar2[] = {3, 4, 5, 5, 10} ar3[] = {5, 5, 10, 20} Output: 5, 5
  - Idea is similar to two arrays.
  - Maintain three pointers i, j, k initially set to first element of arr1, arr2, arr3 respectively
  - Iterate through three arrays while all arrays have elements while (i < n1 && j < n2 && k < n3)
    - If elements pointed by i, j and k are same, we can simply print any of them as common element and move ahead in all three arrays.
	- If arr1[i] is less than arr2[j], then move pointer i
	- If arr2[j] is less than arr2[k], then move pointer j
	- else move pointer k (We reach here when x > y and y > z, i.e., z is smallest)
 - Time: O(n1+n2+n3) 

67. Construct an array from its pair-sum array
	Given a pair-sum array and size of the original array (n), construct the original array.
	A pair-sum array for an array is the array that contains sum of all pairs in ordered form. For example pair-sum array for arr[] = {6, 8, 3, 4} is {14, 9, 10, 11, 12, 7}.
	In general, pair-sum array for arr[0..n-1] is {arr[0]+arr[1], arr[0]+arr[2], ……., arr[1]+arr[2], arr[1]+arr[3], ……., arr[2]+arr[3], arr[2]+arr[4], …., arr[n-2]+arr[n-1}.
	“Given a pair-sum array, construct the original array.”
  - Let the given array be "pair[]" and let there be n elements in original array. 
  - If we take a look at few examples, we can observe that arr[0] is half of pair[0] + pair[1] – pair[n-1]. 
  - Note that the value of pair[0] + pair[1] – pair[n-1] is (arr[0] + arr[1]) + (arr[0] + arr[2]) – (arr[1] + arr[2]).
  - Once we have evaluated arr[0], we can evaluate other elements by subtracting arr[0]. 
  - For example arr[1] can be evaluated by subtracting arr[0] from pair[0], arr[2] can be evaluated by subtracting arr[0] from pair[1].
  - Time:O(n)

68. Count 1’s in a sorted binary array
	Given a binary array sorted in non-increasing order, count the number of 1’s in it.Examples:
	Input: arr[] = {1, 1, 0, 0, 0, 0, 0}
	Output: 2
	Input: arr[] = {1, 1, 1, 1, 1, 1, 1}
	Output: 7
	Input: arr[] = {0, 0, 0, 0, 0, 0, 0}
	Output: 0
  - Variation of binary search. Find the index of last occurrence of 1 using binary search.
  - index + 1 is the count of 1s in the array.
  - if the middle element is the last 1, then return mid+1
    - middle element is 1 and middle is the right most element in the array; a[mid] == 1 and mid == right
	- middle element is 1 and next element to middle element is 0; a[mid] == 1 and a[mid+1] == 0 
  - if the middle is not last 1, then recur the same for the right side
  - else recur for left side 
  - Time:O(Log n)

69. Find Index of 0 to be replaced with 1 to get longest continuous sequence of 1s in a binary array
	Given an array of 0s and 1s, find the position of 0 to be replaced with 1 to get longest continuous sequence of 1s.
	Input: arr[] =  {1, 1, 0, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1} Output: Index 9
	Assuming array index starts from 0, replacing 0 with 1 at index 9 causes the maximum continuous sequence of 1s.
	Input: arr[] =  {1, 1, 1, 1, 0} Output: Index 4
  - Keep track of two indexes: prev_zero - previous zero index, prev_prev_zero - previous to previous zero index
  - Initially set max_count and max_index as 0
  - For every element i from 0 to n-1
    - If current element is 0, then calculate the difference between curr and prev_prev_zero and 
	  if its maximum found so far update max_count = curr - prev_prev_zero and max_index as prev_zero.
	- Update prev_prev_zero = prev_zero and prev_zero = curr for next iteration.
  - For the last encountered zero check the same out the loop if (n-prev_prev_zero > max_count)
  - Time:O(n)

70. K’th Smallest/Largest Element in Unsorted Array
	Given an array and a number k where k is smaller than size of array, we need to find the k’th smallest element in the given array. 
	It is given that all array elements are distinct.
	Input: arr[] = {7, 10, 4, 3, 20, 15}, k = 3 Output: 7
	Input: arr[] = {7, 10, 4, 3, 20, 15}, k = 4	Output: 10
  (a) O(n) solution for average case
  - Variation of quick sort. In QuickSort, we pick a pivot element, then move the pivot element to its correct position and partition the array around it.
  - The idea is, not to do complete quicksort, but stop at the point where pivot itself is k’th smallest element. 
  - Also, not to recur for both left and right sides of pivot, but recur for one of them according to the position of pivot. 
  - Partition the array by taking the last element as pivot and get position of pivot element in sorted array[same as quicksort]
  - If the position is same as k, return a[pos]
  - If the position is more than k, then recur for left side.
  - else recur for right side
  - Time: worst case time complexity of this method is O(n2), but it works in O(n) on average.
 (b) Expected linear time 
  - The idea is to randomly pick a pivot element. 
  - generate index between l and r, and swap with the right most element.
  - invoke the standard parition method which takes the rightmost element as pivot
 (c) Worst Case Linear Time
  - Divide arr[] into groups where size of each group is 5 except possibly the last group which may have less than 5 elements.  
  - Sort the above created groups and find median of all groups. Find median of all medians.
  - Partition arr[] around median and obtain its position. 
  - If the position is same as k, return a[pos]
  - If the position is more than k, then recur for left side.
  - else recur for right side
  - Time: O(n) in worst case

71. Sort an array in wave form
	Given an unsorted array of integers, sort the array into a wave like array. 
	An array 'arr[0..n-1]' is sorted in wave form if arr[0] >= arr[1] <= arr[2] >= arr[3] <= arr[4] >= ...
	Examples:
	 Input:  arr[] = {10, 5, 6, 3, 2, 20, 100, 80} Output: arr[] = {10, 5, 6, 2, 20, 3, 100, 80} OR
					 {20, 5, 10, 2, 80, 6, 100, 3} OR any other array that is in wave form
	 Input:  arr[] = {20, 10, 8, 6, 4, 2} Output: arr[] = {20, 8, 10, 4, 6, 2} OR {10, 8, 20, 2, 6, 4} OR
					 any other array that is in wave form
	 Input:  arr[] = {2, 4, 6, 8, 10, 20} Output: arr[] = {4, 2, 8, 6, 20, 10} OR any other array that is in wave form
	 Input:  arr[] = {3, 6, 5, 10, 7, 20} Output: arr[] = {6, 3, 10, 5, 20, 7} OR any other array that is in wave form
  - The idea is based on the fact that if we make sure that all even positioned (at index 0, 2, 4, ..) 
    elements are greater than their adjacent odd elements, we don’t need to worry about odd positioned element. 
  - For every element i from 0 to n-1 incrementing by 2 for every iteration
	- If current element is smaller than previous odd element, swap previous and current.
	- If current element is smaller than next odd element, swap next and current.
  - Time: O(n)

72. Given two sorted arrays such the arrays may have some common elements. 
	Find the sum of the maximum sum path to reach from beginning of any array to end of any of the two arrays. 
	We can switch from one array to another array only at common elements.
	Expected time complexity is O(m+n) where m is the number of elements in ar1[] and n is the number of elements in ar2[].
	Examples:
	Input:  ar1[] = {2, 3, 7, 10, 12}, ar2[] = {1, 5, 7, 8} Output: 35 (sum of 1 + 5 + 7 + 10 + 12)
	We start from first element of arr2 which is 1, then we move to 5, then 7.  From 7, we switch to ar1 (7 is common)
	and traverse 10 and 12.
	Input:  ar1[] = {10, 12}, ar2 = {5, 7, 9} Output: 22 (sum of 10 and 12) Since there is no common element, we need to take all 
	elements from the array with more sum.
	Input:  ar1[] = {2, 3, 7, 10, 12, 15, 30, 34} ar2[] = {1, 5, 7, 8, 10, 15, 16, 19}
	Output: 122 (sum of 1, 5, 7, 8, 10, 12, 15, 30, 34)
  - Idea is to calculate sums of elements between all common points for both arrays. 
  - Whenever we see a common point, we compare the two sums and add the maximum of two to the result. 
  - Keep track of three values result, sum1 & sum2 to calculate the sum of elements in ar1[] and ar2[] respectively.
    These sums are between two common points.
  - Have two pointers i, j for ar1[] and ar2[], initially set to 0.
  - Traverse elements of both arrays ie while (i < m && j < n)  
    - If current element of ar1[] is smaller than current element of ar2[], then update sum1, 
	  else if current element of ar2[] is smaller, then update sum2.
	- If current element of ar1[] and ar2[] are same, then take the maximum of sum1 and sum2 and add it to the result. 
	  Keep updating result while there are more common elements
  - Update sum1 by adding remaining elements of ar1[]
  - Update sum2 by adding remaining elements of ar2
  - Add maximum of two sums of remaining elements to result.
  - Time :  O(m+n)

73. Sort an array according to the order defined by another array
	Given two arrays A1[] and A2[], sort A1 in such a way that the relative order among the elements will be same as those are in A2. 
	For the elements not present in A2, append them at last in sorted order.
	Input: A1[] = {2, 1, 2, 5, 7, 1, 9, 3, 6, 8, 8} A2[] = {2, 1, 8, 3}	Output: A1[] = {2, 2, 1, 1, 8, 8, 3, 5, 6, 7, 9}
  - Create a temporary array temp of size m and copy contents of A1[] to it.
  - Create another array visited[] and initialize all entries in it as false. 
    visited[] is used to mark those elements in temp[] which are copied to A1[].
  - Sort temp[]
  - Initialize the output index ind as 0.
  - For every element i in A2 from 0 to n-1 
    - Binary search A2[i] in temp[], if present then copy all occurrences to A1[ind] and increment ind. 
	  Also mark the copied elements visited[]
  - Copy all unvisited elements from temp[] to A1[].
  - Time: O((m+n) Logm) [sorting temp - mLogm, binary search of A2 in A1-nLogm]

74. Smallest subarray with sum greater than a given value.
	Given an array of integers and a number x, find the smallest subarray with sum greater than the given value.
	Examples:
	arr[] = {1, 4, 45, 6, 0, 19} x  =  51 Output: 3	Minimum length subarray is {4, 45, 6}
	arr[] = {1, 10, 5, 2, 7} x  = 9	Output: 1 Minimum length subarray is {10}
	arr[] = {1, 11, 100, 1, 0, 200, 3, 2, 1, 250} x = 280 Output: 4 Minimum length subarray is {100, 1, 0, 200}
  - Keep track of following values, 
    - currSum-sum of current subarray, minLengthSoFar-minimum subarray length found so far
	- start and end pointers to indicate the indices of the current subarray start and end. Initially both are set to 0.
  - Loop while end is lesser than N(where N is the size of the array)
    - Keep adding array elements while current subarray sum ie. currSum is smaller than x. Increment end pointer
	- If currSum exceeds x, update minLengthSoFar if end - start is lesser than minLengthSoFar
	- Remove the first start element. increment start
  - Time:O(n)
 
75. Count all distinct pairs with difference equal to k
	Given an integer array and a positive integer k, count all distinct pairs with difference equal to k.
	Examples:
	Input: arr[] = {1, 5, 3, 4, 2}, k = 3 Output: 2	{1, 4} and {5, 2} 
	Input: arr[] = {8, 12, 16, 4, 0, 20}, k = 4	Output: 5 {0, 4}, {4, 8}, {8, 12}, {12, 16} and {16, 20}  
    (a) Sorting 
  - Initialize count as 0
  -	Sort all numbers in increasing order.
  -	Remove duplicates from array.
  -	For each element arr[i]
	- Binary Search for arr[i] + k in subarray from i+1 to n-1.
	- If arr[i] + k found, increment count. 
  - Return count. 	
  - Time: O(nLogn)
	(b) Hashing
  - Initialize count as 0.
  -	Insert all distinct elements of arr[] in a hash map.  While inserting, ignore an element if already present in the hash map.
  - Do following for each element arr[i].
    - Look for arr[i] + k in the hash map, if found then increment count.
    - Look for arr[i] - k in the hash map, if found then increment count.
    - Remove arr[i] from hash table. 
  - Time: O(n)
  
76. Move all zeroes to end of array
	Given an array of random numbers, Push all the zero’s of a given array to the end of the array. 
	For example, if the given arrays is {1, 9, 8, 4, 0, 0, 2, 7, 0, 6, 0}, it should be changed to {1, 9, 8, 4, 2, 7, 6, 0, 0, 0, 0}. 
	The order of all other elements should be same. 
  - Traverse the given array from left to right. 
  - While traversing, maintain count of non-zero elements in array. Let the count be count. Initially set to 0 
  - For every non-zero element arr[i], put the element at 'arr[count]' and increment count. 
  - After complete traversal, all non-zero elements have already been shifted to front end. 'count' is set as index of first 0
  - Now all we need to do is that run a loop which makes all elements zero from 'count' till end of the array.
  - Time: O(n)

77. Merge k sorted arrays
	Given k sorted arrays of size n each, merge them and print the sorted output.
	Example:
	Input:
	k = 3, n =  4
	arr[][] = { {1, 3, 5, 7},
				{2, 4, 6, 8},
				{0, 9, 10, 11}} ;

	Output: 0 1 2 3 4 5 6 7 8 9 10 11 
  - Create an output array of size n*k.
  - Create a min heap of size k and insert 1st element in all the arrays into a the heap
  - Repeat following steps n*k times.
    - Get minimum element from heap (minimum is always at root) and store it in output array.
    - Replace heap root with next element from the array from which the element is extracted. 
	- If the array doesn’t have any more elements, then replace root with infinite. After replacing the root, heapify the tree.
  - Time: The loop runs n*k times. In every iteration of loop, we call heapify which takes O(Logk) time. O(nk Logk)
 
78. Stable marriage problem
	Given N men and N women, where each person has ranked all members of the opposite sex in order of preference, 
	marry the men and women together such that there are no two people of opposite sex that would prefer each other over their assigned partners.
	Let there be two men m1 and m2 and two women w1 and w2.
	Let m1's list of preferences be {w1, w2}
	Let m2's list of preferences be {w1, w2}
	Let w1's list of preferences be {m1, m2}
	Let w2's list of preferences be {m1, m2}
	The matching { {m1, w2}, {w1, m2} } is not stable because m1 and w1 would prefer each other over their assigned partners. 
	The matching {m1, w1} and {m2, w2} is stable 
  - Initialize all men and women to free
	while there exist a free man m who still has a woman w to propose to 
	{
		w = m's highest ranked such woman to whom he has not yet proposed
		if w is free
		   (m, w) become engaged
		else some pair (m', w) already exists
		   if w prefers m to m'
			  (m, w) become engaged
			   m' becomes free
		   else
			  (m', w) remain engaged    
	}  
  - Time: O(n^2)
  
79. Find the minimum element in a sorted and rotated array
	A sorted array is rotated at some unknown point, find the minimum element in it.
	Following solution assumes that all elements are distinct.
	Examples
	Input: {5, 6, 1, 2, 3, 4} Output: 1
	Input: {1, 2, 3, 4} Output: 1
	Input: {2, 1} Output: 1    
  - examples {2, 2, 2, 2, 2, 2, 2, 2, 0, 1, 1, 2} and {2, 2, 2, 0, 2, 2, 2, 2, 2, 2, 2, 2)
  - Same like the varation of binary search.
  - one extra condition is that if first element, middle element and last element are same	
    return the rcursive function as minimum of same functinon with low to mid-1 and 
	binary function with inout slike min+1 and right
	Time:o(Logn) worst case O(n)

80. Count the number of possible triangles
	Given an unsorted array of positive integers. Find the number of triangles that can be formed with 
	three different array elements as three sides of triangles. For a triangle to be possible from 3 values, 
	the sum of any two values (or sides) must be greater than the third value (or third side).
	If the input array is {4, 6, 3, 7}, the output should be 3. {3, 4, 6}, {4, 6, 7} and {3, 6, 7}. 
	Input array {10, 21, 22, 100, 101, 200, 300}. There can be 6 possible triangles: 
	{10, 21, 22}, {21, 100, 101}, {22, 100, 101}, {10, 100, 101}, {100, 101, 200} and {101, 200, 300}
  - a + b > c condition shall hold good for three sides of a triangle
  - Sort the array in increasing order
  - Keep three pointers i, j, k initially set to first, second and third element
  - Fix i, j and find the rightmost k such that a[i] + a[j] > a[k].  
    The number of triangles that can be formed with ‘arr[i]’ and ‘arr[j]’ as two sides is ‘k – j’. 
	Add ‘k – j’ to count of triangles.
  - Increment j to fix the second element again and repeat the above steps.
  - Time:O(n^2)

81. Suppose there is a circle. There are n petrol pumps on that circle. You are given two sets of data.
	1. The amount of petrol that every petrol pump has.
	2. Distance from that petrol pump to the next petrol pump.
	Calculate the first point from where a truck will be able to complete the circle 
	(The truck will stop at each petrol pump and it has infinite capacity). Expected time complexity is O(n). 
	Assume for 1 litre petrol, the truck can go 1 unit of distance.
	eg, let there be 4 petrol pumps with amount of petrol and distance to next petrol pump value pairs as {4, 6}, {6, 5}, {7, 3} and {4, 5}. 
	The first point from where truck can make a circular tour is 2nd petrol pump. Output should be "start = 1" (index of 2nd petrol pump).  
	
82. 
 
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
	
	
	
	
	
	
	
	
	
	